<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>{{name}}</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='post.css') }}" />
  <link rel="shortcut icon" href="{{ url_for('static', filename='favicon.ico') }}" />
</head>

<body>
  <div class="container" id="container">
    <div class="servers">
      {% for srvr in mysrvr: %}
      <div class="text-block" onclick='gotoserver(this)'>
        <div class="SERVER">{{srvr}}</div>
      </div>
      {% endfor %}
    </div>
    <div class="leftside">
      <div class="header">
        <div class="imgtext">
          <a class="arrow" id="back" style="text-decoration: none; font-size: 1.1em;display: none;"><ion-icon
              name="arrow-back-outline"></ion-icon></a>
          <div class="userimg">
            <img src="{{url_for('static',filename='profile.webp')}}" alt="pic" class="cover" />
          </div>
          <h4>{{name}}<br /><span>Server:</span>&nbsp;<span id="server">{{server}}</span></h4>
        </div>
      </div>
      <div class="search_channel">
        <div id="search_form">
          <form>
            <input autocomplete="off" id="search_input" placeholder="Search channel/person" type="text"
              class="search_channel" />
          </form>
        </div>
      </div>
      <div class="channel_list" id="channel_list">
        {% for channel in channels: %}
        <div class="block" onclick="goto(this)" data-key="{{channel.id}}">
          <div class="imgbx"><img src="/static/profile.webp" alt="pic" class="cover"></div>
          <div class="details">
            <div class="name">
              <h4 class="chnl">{{channel.name}}</h4>
            </div>
            <div class="creator">
              <p>created by {{channel.user.username}}</p>
            </div>
          </div>
        </div>
        {% endfor %}
      </div>
    </div>
    <div class="rightside">
      <div id="userside" style="display: block;">
        <div class="header">
          <div class="useless">
            <a id="download" href="download/{{server}}">Download State</a>
            <p onclick='socket.emit("changeServer",false)' id="delete">Logout</p>
            <form id="logout" action="/servers" method="post" style="display: none;"></form>
            <!-- <input style="display: none;" id="listen_call" onclick="listencall()" type="button"
              value="Listen for calls"> -->
            <!-- <input type="button" onclick="sendOffer()" value="Make Call"> -->
          </div>
        </div>
        <div class="chatbox" id="user">
          <p>
          <h2>Welcome {{name}}</h2><br>
          </p>
          <h4>People live in <span id="server2">{{server}}</span>:</h4>
          <ul style="cursor: pointer;" type="bullet" id="userlive">
            <br>
            {% for people in peoples %}
            <li onclick="GOTOfrnd('{{people}}')">{{people}}</li>
            {% endfor %}
          </ul>
        </div>
        <div id="newform" class="chatbox_input">
          <form class="form" id="newform">
            <input autocomplete="off" id="newchannel" placeholder="Add channel" type="text" class="search_channel">
            <!-- <input type="submit" value="Add Topic"> -->
            <button class="send" type="submit"><ion-icon name="arrow-forward-outline"></ion-icon></button>
          </form>

        </div>
      </div>
      <div id="chatside" style="display: none;">
        <div class="header">
          <div class="imgtext">
            <h2 id="topic">&nbsp<br /></h2>

          </div>
          <div class="channel_info">
            <div id="users" class="info">
              <ion-icon class="info_icon" name="people-outline"></ion-icon>
              <div id="user-count">(...)</div>
            </div>
            <!-- <div id="both" class="info" >&nbsp&nbsp&nbsp</div> -->
            <div id="attachment" class="info">
              <ion-icon class="info_icon" name="attach-outline"></ion-icon>
            </div>
          </div>
        </div>
        <div id="box" class="chatbox">
          <div class="arrow" onclick="gethistory()" id="UP">
            <ion-icon name="arrow-up-outline"></ion-icon>
          </div>
          <div id="chats">
            <hr id="breaker" />
            <!-- <div  class="useless">
                      <button onclick="darkfunction()" style="align-items:center;">chat useless</button>                   
                      <button onclick="location.href='/delete_short'" id="delete">Delete</button>
                  </div>
                  <script>
                      function darkfunction() {
                          var mybody=document.body
                          var hide=document.getElementById("inputfield")
                          if (hide.value=="True"){
                              mybody.classList.remove("darkbody");
                              hide.value="False";
                          }
                          else {
                              hide.value="True";
                              mybody.classList.toggle("darkbody");
                          }
                      }
                  </script>
                  <div class="shortBox" id="shortBox"> <p>under maintainance...<z/p>
                      {% for post in feelings: %}
                          {% if post.sender_id==name.id: %}
                              <div class="short my_short">
                                  <p>{{post.data}}</span> </p>
                              </div>
                          {% else: %}
                              <div class="short frnd_short">
                                  <p >{{post.data}} - <span>{{post.sender.username}}</p>
                              </div>
                          {% endif %}
                      {% endfor %}
                  </div> -->
            <!-- <script>
              // var objDiv1 = document.getElementById("shortBox");
              var objDiv2 = document.getElementById("box");
              // objDiv1.scrollTop = objDiv1.scrollHeight;
              objDiv2.scrollTop = objDiv2.scrollHeight;
            </script> -->
          </div>
        </div>

        <div class="chatbox_input" id="chatinput">
          <form class="form">
            <input autofocus autocomplete="off" type="text" name="post" placeholder="Message" id="text_message" />
            <!-- <div contenteditable="true" 
            id="text_message" class ="inputarea" data-text="Message">       
             </div> -->

            <!-- <input type="hidden" name="hide" default="False" value="{{hide}}" id="inputfield" /> -->
          </form>
          <button class="emoji">&#x1F603;</button>
        </div>
      </div>
    </div>
  </div>
  <div class="sidebar">
    <div class="user-list" id="listblock">
      People:
      <ul id="user-list"></ul>
    </div>
    <div class="pins" id="pins">
      Media:
      <div id="mediaPool">
      </div>
      <input id="media" style="display: flex; flex-wrap: wrap;" type="file" name="files" autocomplete="off" />
      <div style="display: flex;"> <button id="upload">Send</button>
        <div id="loading-circle"></div>
      </div>
    </div>
  </div>
  <div id="emojiPallet">
  </div>
  <div id="pintab" class="pintab">
    <nav>
      <div id="pinname" style="cursor: auto;" class="navitems center-items"></div>
      <div class="navitems right-items">
        <div></div>
        <ion-icon name="browsers-sharp" onclick="pintab.classList.toggle('pintab');pintab.classList.toggle('fullscreen')"></ion-icon>
        <ion-icon name="close-outline" onclick="cancelpinned()"></ion-icon>
      </div>
    </nav>
    <div id="content">

    </div>
  </div>
  <script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script>
  <script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script>

  <!-- adding socket -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"
    integrity="sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA=="
    crossorigin="anonymous"></script>
  <script type="text/javascript" charset="utf-8">
    var socket = io({
      transports: ["websocket"],
    });
    const body = document.getElementById("container");
    const chatbox = document.getElementById("chats");
    const server = document.getElementById("server")
    const line = document.getElementById("breaker");
    const channel_list = document.getElementById("channel_list")
    const message_form = document.getElementById("chatinput");
    const message_input = document.getElementById("text_message");
    const search_form = document.getElementById("search_form");
    const search_input = document.getElementById("search_input");
    const userlive = document.getElementById("userlive")
    const userList = document.getElementById("user-list");
    const both = document.getElementById("both")
    const listblock = document.getElementById("listblock")
    const Users = document.getElementById("users");
    const userCount = document.getElementById("user-count")
    const Top = document.getElementById("UP");
    const box = document.getElementById("box");
    const chatside = document.getElementById("chatside");
    const userside = document.getElementById("userside");
    const back = document.getElementById("back")
    const Newform = document.getElementById("newform");
    const newChannel = document.getElementById("newchannel");
    const pintab = document.getElementById("pintab");
    const attachment = document.getElementById("attachment");
    const pins = document.getElementById("pins")
    const mediaPool = document.getElementById("mediaPool")
    const loadingCircle = document.getElementById('loading-circle');
    const pinname = document.getElementById("pinname")
    const content = document.getElementById("content")
    attachment.checked = true
    let pinsvisibility = true;
    let listvisibility = true;
    let emojivisibility = true;
    let listhide;
    let emojihide;
    let pinshide;
    const emojiPallet = document.getElementById("emojiPallet")
    const emojis = [
      "ðŸ˜„", "ðŸ˜ƒ", "ðŸ˜€", "ðŸ˜Š", "â˜ºï¸", "ðŸ˜‰", "ðŸ˜", "ðŸ˜˜", "ðŸ˜š", "ðŸ˜—",
      "ðŸ˜™", "ðŸ˜œ", "ðŸ˜", "ðŸ˜›", "ðŸ˜³", "ðŸ˜", "ðŸ˜”", "ðŸ˜Œ", "ðŸ˜’", "ðŸ˜ž",
      "ðŸ˜£", "ðŸ˜¢", "ðŸ˜‚", "ðŸ˜­", "ðŸ˜ª", "ðŸ˜¥", "ðŸ˜°", "ðŸ˜…", "ðŸ˜“", "ðŸ˜©",
      "ðŸ˜«", "ðŸ˜¨", "ðŸ˜±", "ðŸ˜ ", "ðŸ˜¡", "ðŸ˜¤", "ðŸ˜–", "ðŸ˜†", "ðŸ˜‹", "ðŸ˜·",
      "ðŸ˜Ž", "ðŸ˜´", "ðŸ˜µ", "ðŸ˜²", "ðŸ˜Ÿ", "ðŸ˜¦", "ðŸ˜§", "ðŸ˜ˆ", "ðŸ‘¿", "ðŸ˜®",
      "ðŸ˜¬", "ðŸ˜", "ðŸ˜•", "ðŸ˜¯", "ðŸ˜¶", "ðŸ˜‡", "ðŸ˜", "ðŸ˜‘", "ðŸ‘²", "ðŸ‘³",
      "ðŸ‘®", "ðŸ‘·", "ðŸ’‚", "ðŸ‘¶", "ðŸ‘¦", "ðŸ‘§", "ðŸ‘¨", "ðŸ‘©", "ðŸ‘´", "ðŸ‘µ",
      "ðŸ‘±", "ðŸ‘¼", "ðŸ‘¸", "ðŸ˜º", "ðŸ˜¸", "ðŸ˜»", "ðŸ˜½", "ðŸ˜¼", "ðŸ™€", "ðŸ˜¿",
      "ðŸ˜¹", "ðŸ˜¾", "ðŸ‘¹", "ðŸ‘º", "ðŸ™ˆ", "ðŸ™‰", "ðŸ™Š", "ðŸ’€", "ðŸ‘½", "ðŸ’©",
      "ðŸ”¥", "âœ¨", "ðŸŒŸ", "ðŸ’«", "ðŸ’¥", "ðŸ’¢", "ðŸ’¦", "ðŸ’§", "ðŸ’¤", "ðŸ’¨",
      "ðŸ‘‚", "ðŸ‘€", "ðŸ‘ƒ", "ðŸ‘…", "ðŸ‘„", "ðŸ‘", "ðŸ‘Ž", "ðŸ‘Œ", "ðŸ‘Š", "âœŠ",
      "ðŸ‘‹", "âœ‹", "ðŸ‘", "ðŸ‘†", "ðŸ‘‡", "ðŸ‘‰", "ðŸ‘ˆ", "ðŸ™Œ", "ðŸ™", "ðŸ‘",
      "ðŸ’ª", "ðŸš¶", "ðŸƒ", "ðŸ’ƒ", "ðŸ‘«", "ðŸ‘ª", "ðŸ‘¬", "ðŸ‘­", "ðŸ’", "ðŸ’‘",
      "ðŸ‘¯", "ðŸ™†", "ðŸ™…", "ðŸ’", "ðŸ™‹", "ðŸ’†", "ðŸ’‡", "ðŸ’…", "ðŸ‘°", "ðŸ™Ž",
      "ðŸ™", "ðŸ™‡", "ðŸŽ©", "ðŸ‘‘", "ðŸ‘’", "ðŸ‘Ÿ", "ðŸ‘ž", "ðŸ‘¡", "ðŸ‘ ", "ðŸ‘¢",
      "ðŸ‘•", "ðŸ‘”", "ðŸ‘š", "ðŸ‘—", "ðŸŽ½", "ðŸ‘–", "ðŸ‘˜", "ðŸ‘™", "ðŸ’¼", "ðŸ‘œ",
      "ðŸ‘", "ðŸ‘›", "ðŸ‘“", "ðŸŽ€", "ðŸŒ‚", "ðŸ’„", "ðŸ’›", "ðŸ’™", "ðŸ’œ", "ðŸ’š",
      "â¤ï¸", "ðŸ’”", "ðŸ’—", "ðŸ’“", "ðŸ’•", "ðŸ’–", "ðŸ’ž", "ðŸ’˜", "ðŸ’Œ", "ðŸ’‹",
      "ðŸ’", "ðŸ’Ž", "ðŸ‘¤", "ðŸ‘¥", "ðŸ’¬", "ðŸ‘£", "ðŸ’­", "ðŸ¶", "ðŸº", "ðŸ±",
      "ðŸ­", "ðŸ¹", "ðŸ°", "ðŸ¸", "ðŸ¯", "ðŸ¨", "ðŸ»", "ðŸ·", "ðŸ½", "ðŸ®",
      "ðŸ—", "ðŸµ", "ðŸ’", "ðŸ´", "ðŸ‘", "ðŸ˜", "ðŸ¼", "ðŸ§", "ðŸ¦", "ðŸ¤",
      "ðŸ¥", "ðŸ£", "ðŸ”", "ðŸ", "ðŸ¢", "ðŸ›", "ðŸ", "ðŸœ", "ðŸž", "ðŸŒ",
      "ðŸ™", "ðŸš", "ðŸ ", "ðŸŸ", "ðŸ¬", "ðŸ³", "ðŸ‹", "ðŸ„", "ðŸ", "ðŸ€",
      "ðŸƒ", "ðŸ…", "ðŸ‡", "ðŸ‰", "ðŸŽ", "ðŸ", "ðŸ“", "ðŸ•", "ðŸ–", "ðŸ",
      "ðŸ‚", "ðŸ²", "ðŸ¡", "ðŸŠ", "ðŸª", "ðŸ†", "ðŸˆ", "ðŸ©", "ðŸ¾", "ðŸ’",
      "ðŸŒ¸", "ðŸŒ·", "ðŸ€", "ðŸŒ¹", "ðŸŒ»", "ðŸŒº", "ðŸ", "ðŸƒ", "ðŸ‚", "ðŸŒ¿",
      "ðŸŒ¾", "ðŸ„", "ðŸŒµ", "ðŸŒ´", "ðŸŒ²", "ðŸŒ³", "ðŸŒ°", "ðŸŒ±", "ðŸŒ¼", "ðŸŒ",
      "ðŸŒž", "ðŸŒ", "ðŸŒš", "ðŸŒ‘", "ðŸŒ’", "ðŸŒ“", "ðŸŒ”", "ðŸŒ•", "ðŸŒ–", "ðŸŒ—",
      "ðŸŒ˜", "ðŸŒœ", "ðŸŒ›", "ðŸŒ™", "ðŸŒ", "ðŸŒŽ", "ðŸŒ", "ðŸŒ‹", "ðŸŒŒ", "â›…",
      "â›„", "ðŸŒ€", "ðŸŒ", "ðŸŒˆ", "ðŸŒŠ", "ðŸŒ‰", "ðŸŒ‡", "ðŸŒ†", "ðŸŒ„", "ðŸŒƒ",
      "ðŸŒ", "ðŸŒŽ", "ðŸŒ", "ðŸŒ‹", "ðŸŒŒ", "â›…", "â›„", "ðŸŒ€", "ðŸŒ", "ðŸŒˆ",
      "ðŸŒŠ", "ðŸŒ‰", "ðŸŒ‡", "ðŸŒ†", "ðŸŒ„", "ðŸŒƒ", "ðŸŒ‚", "â˜‚ï¸", "â˜”", "ðŸ’§",
      "ðŸ’¦", "ðŸŒŠ", "ðŸ", "ðŸŽ", "ðŸ", "ðŸŠ", "ðŸ‹", "ðŸŒ", "ðŸ‰", "ðŸ‡",
      "ðŸ“", "ðŸˆ", "ðŸ’", "ðŸ‘", "ðŸ", "ðŸ…", "ðŸ†", "ðŸŒ½", "ðŸ ", "ðŸž",
      "ðŸ—", "ðŸ–", "ðŸ¤", "ðŸ³", "ðŸ”", "ðŸŸ", "ðŸŒ­", "ðŸ•", "ðŸ", "ðŸŒ®",
      "ðŸŒ¯", "ðŸœ", "ðŸ²", "ðŸ¥", "ðŸ£", "ðŸ±", "ðŸ›", "ðŸ™", "ðŸš", "ðŸ˜",
      "ðŸ¢", "ðŸ¡", "ðŸ§", "ðŸ¨", "ðŸ¦", "ðŸ°", "ðŸŽ‚", "ðŸ®", "ðŸ¬", "ðŸ­",
      "ðŸ«", "ðŸ¿", "ðŸ©", "ðŸª", "ðŸŒ°", "ðŸ¯", "ðŸŽ", "ðŸ", "ðŸŠ", "ðŸ‹",
      "ðŸ’", "ðŸ‡", "ðŸ‰", "ðŸ“", "ðŸ‘", "ðŸˆ", "ðŸŒ", "ðŸ", "ðŸ", "ðŸ ",
      "ðŸ†", "ðŸŒ½", "ðŸ„", "ðŸŒ°", "ðŸž", "ðŸž", "ðŸ–", "ðŸ—", "ðŸ”", "ðŸŸ",
      "ðŸŒ­", "ðŸ•", "ðŸ", "ðŸŒ®", "ðŸŒ¯", "ðŸœ", "ðŸ²", "ðŸ¥", "ðŸ›", "ðŸ™",
      "ðŸš", "ðŸ˜", "ðŸ¢", "ðŸ¡", "ðŸ§", "ðŸ¨", "ðŸ¦", "ðŸ°", "ðŸŽ‚", "ðŸ®",
      "ðŸ¬", "ðŸ­", "ðŸ«", "ðŸ¿", "ðŸ©", "ðŸª", "ðŸ¯", "ðŸŒ°"
    ];


    // both.addEventListener('mouseenter', () => {
    //   // Trigger the mouseenter event of the attachment
    //   attachment.dispatchEvent(new Event('mouseenter'));
    //   Users.dispatchEvent(new Event('mouseenter'));
    // });

    // both.addEventListener('mouseleave', () => {
    //   // Trigger the mouseleave event of the attachment
    //   attachment.dispatchEvent(new Event('mouseleave'));
    //   Users.dispatchEvent(new Event('mouseenter'));
    // });

    const chunkSize = 524288; // 0.5 MB in bytes


    // document.getElementById("upload").onclick = async function () {
    //   const file = document.getElementById("media").files[0];
    //   const metaData = new FormData();
    //   metaData.append('file', file);
    //   try {
    //     const response = await fetch('/media', {
    //       method: 'POST',
    //       body: metaData
    //     });
    //     const data = await response.text();
    //     console.log('Response:', data);
    //   } catch (error) {
    //     console.error('Error:', error);
    //   }
    // }
    function updateLoadingCircle(value) {
      loadingCircle.innerText = value
    }
    document.getElementById("upload").onclick = async function () {
      if (document.getElementById("media").files[0] == null) {
        return
      }
      document.getElementById("loading-circle").style.display = "block"
      const file = document.getElementById("media").files[0];
      const Total = Math.ceil(file.size / chunkSize);
      const metaData = new FormData();
      metaData.append('name', file.name);
      metaData.append('typ', file.type);
      metaData.append('total', Total);
      metaData.append('uuid', "");

      try {
        const response = await fetch('/media', {
          method: 'POST',
          body: metaData
        });
        const data = await response.text();
        console.log('Response:', data);
        const uuid = data;
        let seq = 0;
        updateLoadingCircle(seq);
        while (seq <= Total) {
          const offset = chunkSize * seq;
          const chunk = file.slice(offset, offset + chunkSize);
          console.log(offset, offset + chunkSize);
          seq = await sendSeqChunk(seq, chunk, uuid);
          updateLoadingCircle(Math.round(seq * 100 / Total));
          console.log(seq)
        }
        document.getElementById("media").value = '';
        document.getElementById("loading-circle").style.display = "none"
      } catch (error) {
        console.error('Error:', error);
      }
    };

    async function sendSeqChunk(seq, chunk, uuid) {
      try {
        console.log(seq);
        console.log(chunk);
        const fileData = new FormData();
        fileData.append('chunk', chunk);
        fileData.append('seq', seq);
        fileData.append('uuid', uuid);

        const response = await fetch('/media', {
          method: 'POST',
          body: fileData
        });
        const data = await response.text();
        return data;
      } catch (error) {
        console.error('Error:', error);
      }
    }

    function showfile(mime,url){
      console.log("showing file")
      if (mime.toLowerCase().includes("image")) {
        console.log("showing image file");
        const img = document.createElement("img");
        img.classList.add("image");
        img.src = url;
        content.appendChild(img);
      } else if (mime.toLowerCase().includes("video")) {
        console.log("showing video file");
        const video = document.createElement('video');
        video.classList.add("image");
        video.controls = true;
        video.src = url;
        content.appendChild(video);
      } else if (mime.toLowerCase().includes("text")) {
        console.log("showing div file");
        const div = document.createElement("embed");
        fetch(url)
          .then(response => response.text())
          .then(text =>{
            div.innerText=text
          })
        div.classList.add("image");
        content.appendChild(div);
      } else {
        console.log("showing div file");
        const embed = document.createElement("embed");
        embed.classList.add("image");
        embed.style.flexGrow="1";
        embed.width = '100%';
        embed.height = '100%';
        embed.type = mime;
        embed.src = url;
        content.appendChild(embed);
      }
    }

    function showpinned(data) {
      if(pinname.dataset.key==data[1]){
        return
      }
      body.classList.add('blur');
      pintab.style.display = "block";
      pinname.innerText = data[0]
      pinname.setAttribute("data-key",data[1])
      content.innerHTML = ""
      let url = localStorage.getItem(data[1]);
      if (!url) {
        // key doesnot exist
        console.log("sending request to "+"/media/" + data[1].toString())
        fetch("/media/" + data[1].toString())
          .then(response => response.blob())
          .then(Data => {
            // geneate url
            console.log(Data)
            url = URL.createObjectURL(Data)
            // store this url 
            console.log(url)
            localStorage.setItem(data[1], url);
            showfile(data[2],url)
          })
          .catch(error => {
            console.error('Error:', error);
          });
      }else{
        showfile(data[2],url)
      }
      
      // const fileInput = document.getElementById('fileInput');
      // const file = fileInput.files[0];

      // const fileContainer = document.getElementById('fileContainer');
      // fileContainer.innerHTML = ''; // Clear any existing content

      // if (file.type.includes('image')) {
      //   // If it's an image file, display the image
      //   const img = document.createElement('img');
      //   img.src = URL.createObjectURL(file);
      //   fileContainer.appendChild(img);
      // } else if (file.type.includes('video')) {
      //   // If it's a video file, display a video player
      //   const video = document.createElement('video');
      //   video.controls = true;
      //   video.src = URL.createObjectURL(file);
      //   fileContainer.appendChild(video);
      // } else if (file.type.includes('pdf')) {
      //   // If it's a PDF file, display a PDF viewer
      //   const pdfViewer = document.createElement('iframe');
      //   pdfViewer.src = URL.createObjectURL(file);
      //   fileContainer.appendChild(pdfViewer);
      // } else {
      //   // For other file types, display a download link
      //   const downloadLink = document.createElement('a');
      //   downloadLink.href = URL.createObjectURL(file);
      //   downloadLink.innerText = 'Download File';
      //   fileContainer.appendChild(downloadLink);
      // }




    }

    function cancelpinned() {
      pintab.style.display = "none";
      pinname.innerText=""
      pinname.dataset.key=""
      body.classList.remove('blur');
      content.innerHTML = ""
    }



    makeHoverable(attachment, pins, pinsvisibility, pinshide)

    emojis.forEach(emoji => {
      let bx = document.createElement('span')
      bx.innerText = emoji
      bx.classList.add('emoG')
      bx.setAttribute('onclick', 'add("' + emoji + '")')
      emojiPallet.appendChild(bx)
    });

    function add(emoji) {
      if (chatside.style.display == "block") {
        message_input.value += emoji + " "
      } else {
        newChannel.value += emoji + " "
      }
    }

    function rearrange() {
      search = search_input.value.toLowerCase();
      search_input.value = ""
      Array.from(document.getElementsByClassName("name")).forEach(name => {
        if (name.innerText.toLowerCase().includes(search)) {
          channel_list.insertAdjacentElement("afterbegin", name.parentElement.parentElement)
        }
      })
    }

    function gethistory() {
      socket.emit("getHistory");
    }

    function show(side) {
      if (side === "chatside") {
        if (chatside.style.display === "none") {
          userside.style.display = "none"
          chatside.style.display = "block"
          back.style.display = "block"
        }
      } else {
        if (userside.style.display === "none") {
          chatside.style.display = "none"
          userside.style.display = "block"
          back.style.display = "none"
          chatbox.innerHTML = ""
          if (document.getElementsByClassName("active").length != 0) {
            document.getElementsByClassName("active")[0].classList.remove("active")
          }
        }
      }
    }

    function emphasize() {
      show("chatside")
      chatbox.innerHTML = ""
      userList.innerHTML = "";
      userCount.innerText = "(...)";
    }

    function goto(Newchannel) {
      let active = document.getElementsByClassName("active")
      if (active[0] != Newchannel) {
        if (active.length != 0) {
          active[0].classList.remove("active");
        }
        Newchannel.classList.add("active")
        if (Newchannel.childElementCount == 3) {
          Newchannel.children[2].remove()
        }
        document.getElementById("topic").innerText = Newchannel.innerText.split('\n')[0]
        emphasize()
        pins.style.display = "none";
        pinsvisibility = true;
        listblock.style.display = "none";
        listvisibility = true;
        userList.innerHTML = "";
        userCount.innerText = "(...)";
        message_input.value = ""
        socket.emit("change", { "channel": Newchannel.dataset.key });
      }
    }

    function gotofrnd(Frnd) {
      let active = document.getElementsByClassName("active")
      if (active[0] != Frnd) {
        if (active.length != 0) {
          active[0].classList.remove("active");
        }
        Frnd.classList.add("active")
        if (Frnd.childElementCount == 3) {
          Frnd.children[2].remove()
        }
        document.getElementById("topic").innerText = Frnd.innerText
        emphasize()
        socket.emit("change", { "Frnd": Frnd.innerText });
      }
    }

    function gotoserver(Newserver) {
      if (server.innerText != Newserver.innerText) {
        userlive.innerHTML = "";
        userList.innerHTML = "";
        userCount.innerText = "(...)";
        channel_list.innerHTML = "";
        if (Newserver.childElementCount == 2) { Newserver.children[1].remove() }
        socket.emit("changeServer", Newserver.innerText)
      }
    }

    makeHoverable(Users, listblock, listvisibility, listhide)
    const emoji_btns = document.getElementsByClassName("emoji")
    Array.from(emoji_btns).forEach(emoji_btn => {
      makeHoverable(emoji_btn, emojiPallet, emojivisibility, emojihide)
    });
    function makeHoverable(btn, block, visibility, time) {
      let mouseleave = function () {
        time = setTimeout(() => {
          if (visibility) {
            block.style.display = "none";
            btn.style.color = "black";
          }
        }, 100);
      }
      let blockenter = function () {
        clearTimeout(time);
        block.style.display = "block";
        btn.style.color = "aquamarine";
      }
      let btnenter = function () {
        clearTimeout(time)
        block.style.display = "block";
        btn.style.color = "aquamarine";
      }
      btn.addEventListener("mouseenter", btnenter)
      btn.addEventListener("mouseleave", mouseleave)
      block.addEventListener("mouseenter", blockenter);
      block.addEventListener("mouseleave", mouseleave)


      btn.addEventListener("click", () => {
        clearTimeout(time);
        if (visibility) {
          block.style.display = "block";
          btn.style.color = "aquamarine";
          console.log("remove eventlistener")
          btn.removeEventListener("mouseenter", btnenter);
          btn.removeEventListener("mouseleave", mouseleave);
          block.removeEventListener("mouseenter", blockenter);
          block.removeEventListener("mouseleave", mouseleave);
          visibility = false;
        } else {
          console.log("add eventlistener")
          btn.addEventListener("mouseenter", btnenter)
          btn.addEventListener("mouseleave", mouseleave)
          block.addEventListener("mouseenter", blockenter);
          block.addEventListener("mouseleave", mouseleave)
          block.style.display = "none";
          btn.style.color = "black";
          visibility = true;
        }
      });
    }

    socket.on("connect", function () {
      socket.emit("Load")
    });

    function addmedia(data) {
      let mediaplate = document.createElement("div")
      mediaplate.classList.add("pinned")
      mediaplate.innerText = data[0]

      mediaplate.setAttribute("onclick", 'showpinned(' + JSON.stringify(data) + ')')
      mediaPool.appendChild(mediaplate)
    }

    socket.on("medias", function (datas) {
      datas.forEach(data => {
        addmedia(data)
      })
    })

    socket.on("media", function (data) {
      addmedia(data)
    })

    socket.on("showNewServer", function (data) {
      server.innerText = data[0]
      document.getElementById("server2").innerText = data[0]
      document.getElementById("download").href = "/download/" + data[0]
      show("userside")
      all = false;
      channel_list.innerHTML = "";
      data[1].forEach(element => {
        let channel = document.createElement("div")
        channel.classList.add("block")
        channel.innerHTML = '<div class="imgbx"><img src="/static/profile.webp" alt="pic" class="cover"></div><div class="details"><div class="name"><h4 class="chnl">' + element[1] + '</h4></div><div class="creator"><p>created by ' + element[2] + '</p></div></div>'
        channel.setAttribute("data-key", element[0])
        channel.setAttribute('onclick', 'goto(this)')
        channel_list.appendChild(channel)
      });
    })

    document.getElementById("back").onclick = function () {
      userList.innerHTML = "";
      userCount.innerText = "(...)";
      message_input.value = ""
      document.getElementById("topic").innerText = ""
      document.getElementById("chats").innerHTML = ""

      show("userside")
      socket.emit("change", 0);
    };

    socket.on("showMessages", function (Msgs) {
      ID = Msgs.pop();
      if (ID == 0) {
        Top.style.visibility = "hidden";
      } else { Top.style.visibility = "visible" }
      Mess = document.getElementsByClassName("message")[0];
      for (var i = 0; i < Msgs.length; i++) {
        var message = document.createElement("div");
        message.classList.add("message");
        if (Msgs[i][0] == "{{name}}") {
          message.classList.add("my_message");
          message.innerHTML =
            "<p>" + Msgs[i][1] + "<span>" + Msgs[i][2] + "</span>" + "</p>";
          chatbox.insertAdjacentElement('afterbegin', message)
        } else {
          message.classList.add("frnd_message");
          message.innerHTML =
            "<p>" + Msgs[i][1] + "<span>" + Msgs[i][2] + "</span>" + "</p>";
          if (i == Msgs.length - 1 || Msgs[i][0] != Msgs[i + 1][0]) {
            var Frnd = document.createElement("div");
            Frnd.classList.add("message");
            Frnd.classList.add("frnd");
            Frnd.innerHTML = '<p>' + Msgs[i][0] + '</p>';
            Frnd.setAttribute('onclick', 'GOTOfrnd("' + Msgs[i][0] + '")')
            // chatbox.insertBefore(message, Top);
            chatbox.insertAdjacentElement('afterbegin', message)
            chatbox.insertAdjacentElement('afterbegin', Frnd)
            // chatbox.insertBefore(Frnd, Top);
          }
          else {
            chatbox.insertAdjacentElement('afterbegin', message)
          }
        }

      }
      if (Mess) {
        Mess.scrollIntoView();
        if (Mess.classList.contains("frnd") && Mess.innerText == Msgs[0][0]) {
          Mess.remove();
        }
      } else { box.scrollTop = box.scrollHeight }
    });

    function GOTOfrnd(user, GOTO = true) {
      let block = document.getElementsByClassName("friend")
      let create = true;
      for (let i = 0; i < block.length; i++) {
        if (block[i].innerText == user) {
          if (GOTO) {
            gotofrnd(block[i].parentElement)
            return
          }
          create = false;
        }
      }
      if (create) {
        let plate = document.createElement("div")
        plate.classList.add("block")
        plate.innerHTML = '<div class="imgbx"><img src="/static/person.png" alt="pic" class="cover"></div><div class="details"><div class="name"><h4 class="friend">' + user + '</h4></div></div></div>'
        plate.setAttribute('onclick', 'gotofrnd(this)')
        channel_list.insertAdjacentElement("afterbegin", plate)
        if (GOTO) {
          gotofrnd(plate);
        }
        return
      }
    }
    socket.on("show_message", function (data) {
      // TO ADD NEW CHILD OF MESSAGE //
      let chat = document.createElement("div");
      chat.classList.add("message");
      if (data[0] == "{{name}}") {
        chat.classList.add("my_message");
      } else {
        chat.classList.add("frnd_message");
        var LM = document.getElementsByClassName("frnd");
        if (LM.length == 0 || LM[LM.length - 1].innerText != data[0]) {
          var Frnd = document.createElement("div");
          Frnd.classList.add("message");
          Frnd.classList.add("frnd");
          Frnd.innerHTML = '<p>' + data[0] + '</p>';
          Frnd.setAttribute('onclick', 'GOTOfrnd("' + data[0] + '")')
          chatbox.appendChild(Frnd);
        }
      }
      chat.innerHTML =
        "<p>" + data[1] + "<span>" + data[2] + "</span>" + "</p>";
      chatbox.appendChild(chat);
      chat.scrollIntoView();
    });
    message_form.onsubmit = function () {
      let message = message_input.value.trim();
      if (message.length) {
        channel_list.insertAdjacentElement("afterbegin", document.getElementsByClassName("active")[0])
        socket.emit("recieve_message", String(message));
        message_input.value = "";
      }
      return false;
    };

    socket.on("serverlive", function (userObj) {
      userlive.innerHTML = ""
      for (const key in userObj) {
        let user = document.createElement("li");
        user.innerText = key;
        user.setAttribute('onclick', 'GOTOfrnd("' + key + '")')
        userlive.appendChild(user);
      }
    })

    socket.on("notify", function (userObj) {
      userList.innerHTML = ""
      for (const key in userObj) {
        let user = document.createElement("li");
        user.innerText = key;
        user.setAttribute('onclick', 'GOTOfrnd("' + key + '")')
        userList.appendChild(user);

      }
      userCount.innerText = " (" + Object.keys(userObj).length + ")";
    });

    function shownotification(to, name) {
      let ls = document.getElementsByClassName(to)
      for (let i = 0; i < ls.length; i++) {
        if (ls[i].innerText == name) {
          if (ls[i].parentElement.parentElement.parentElement.childElementCount != 3) {
            let num = document.createElement('p')
            num.classList.add("update")
            num.innerText = "1";
            ls[i].parentElement.parentElement.parentElement.appendChild(num);
          } else {
            let num = parseInt(ls[i].parentElement.parentElement.parentElement.children[2].innerText)
            ls[i].parentElement.parentElement.parentElement.children[2].innerText = num + 1;
          }
          channel_list.insertAdjacentElement("afterbegin", ls[i].parentElement.parentElement.parentElement)
        }
      }
    }

    socket.on("dm", function (data) {
      GOTOfrnd(data, GOTO = false)
      shownotification('friend', data)
    })
    socket.on("otherupdate", function (data) {
      shownotification('SERVER', data)
    })
    socket.on("currupdate", function (data) {
      shownotification('chnl', data)
    })

    socket.on("Logout", function () {
      document.getElementById("logout").submit()
    })

    search_form.onsubmit = function () {
      let search = search_input.value.trim();
      if (search.length != 0) {
        if (search == '*') {
          search = "";
          all = true;
        }
        socket.emit("search_text", String(search));
        rearrange();
      }
      return false;
    };

    Newform.onsubmit = function () {
      let chnl = newchannel.value.trim();
      if (chnl.length) {
        socket.emit("create", chnl)
        newchannel.value = ""
      }
      return false;
    }
    socket.on("show_this", function (data) {
      if (data.hasOwnProperty("users")) {
        data["users"].forEach(user => {
          GOTOfrnd(user, GOTO = false);
        });
      } else {
        const channel = document.createElement("div")
        channel.classList.add("block")
        channel.innerHTML = '<div class="imgbx"><img src="/static/profile.webp" alt="pic" class="cover"></div><div class="details"><div class="name"><h4 class="chnl">' + data["channel"][1] + '</h4></div><div class="creator"><p>created by ' + data["channel"][2] + '</p><!-- <b onclick="location.href="/delete">x</b> --></div></div>'
        channel.setAttribute("data-key", data["channel"][0])
        channel.setAttribute('onclick', 'goto(this)')
        channel_list.insertAdjacentElement("afterbegin", channel)
      }
    })
    localStorage.clear()
  </script>
</body>

</html>
